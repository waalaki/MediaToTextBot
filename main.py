import os
import threading
import json
import requests
import logging
import time
import base64
import mimetypes
from io import BytesIO
from flask import Flask, request, abort
import telebot
from telebot.types import InlineKeyboardMarkup, InlineKeyboardButton, Update

BOT_TOKEN = os.environ.get("BOT_TOKEN", "")
WEBHOOK_URL_BASE = os.environ.get("WEBHOOK_URL_BASE", "")
PORT = int(os.environ.get("PORT", "8080"))
WEBHOOK_PATH = os.environ.get("WEBHOOK_PATH", "/webhook/")
WEBHOOK_URL = WEBHOOK_URL_BASE.rstrip('/') + WEBHOOK_PATH if WEBHOOK_URL_BASE else ""
REQUEST_TIMEOUT = int(os.environ.get("REQUEST_TIMEOUT", "300"))
MAX_UPLOAD_MB = int(os.environ.get("MAX_UPLOAD_MB", "20"))
MAX_UPLOAD_SIZE = MAX_UPLOAD_MB * 1024 * 1024
MAX_MESSAGE_CHUNK = 4095
REQUIRED_CHANNEL = os.environ.get("REQUIRED_CHANNEL", "")
DOWNLOADS_DIR = os.environ.get("DOWNLOADS_DIR", "./downloads")
GROQ_API_KEY = os.environ.get("GROQ_API_KEY", "")
GROQ_CHAT_URL = os.environ.get("GROQ_CHAT_URL", "https://api.groq.com/openai/v1/chat/completions")
GROQ_TRANSCRIBE_URL = os.environ.get("GROQ_TRANSCRIBE_URL", "https://api.groq.com/openai/v1/audio/transcriptions")
GROQ_MODEL = os.environ.get("GROQ_MODEL", "llama-3.1-8b-instant")
GROQ_TRANSCRIBE_MODEL = os.environ.get("GROQ_TRANSCRIBE_MODEL", "whisper-large-v3")

os.makedirs(DOWNLOADS_DIR, exist_ok=True)
logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')

LANGS = [
("üá¨üáß English","en"), ("üá∏üá¶ ÿßŸÑÿπÿ±ÿ®Ÿäÿ©","ar"), ("üá™üá∏ Espa√±ol","es"), ("üá´üá∑ Fran√ßais","fr"),
("üá∑üá∫ –†—É—Å—Å–∫–∏–π","ru"), ("üá©üá™ Deutsch","de"), ("üáÆüá≥ ‡§π‡§ø‡§®‡•ç‡§¶‡•Ä","hi"), ("üáÆüá∑ ŸÅÿßÿ±ÿ≥€å","fa"),
("üáÆüá© Indonesia","id"), ("üá∫üá¶ –£–∫—Ä–∞—ó–Ω—Å—å–∫–∞","uk"), ("üá¶üáø Az…ôrbaycan","az"), ("üáÆüáπ Italiano","it"),
("üáπüá∑ T√ºrk√ße","tr"), ("üáßüá¨ –ë—ä–ª–≥–∞—Ä—Å–∫–∏","bg"), ("üá∑üá∏ Srpski","sr"), ("üáµüá∞ ÿßÿ±ÿØŸà","ur"),
("üáπüá≠ ‡πÑ‡∏ó‡∏¢","th"), ("üáªüá≥ Ti·∫øng Vi·ªát","vi"), ("üáØüáµ Êó•Êú¨Ë™û","ja"), ("üá∞üá∑ ÌïúÍµ≠Ïñ¥","ko"),
("üá®üá≥ ‰∏≠Êñá","zh"), ("üá≥üá± Nederlands:nl", "nl"), ("üá∏üá™ Svenska","sv"), ("üá≥üá¥ Norsk","no"),
("üáÆüá± ◊¢◊ë◊®◊ô◊™","he"), ("üá©üá∞ Dansk","da"), ("üá™üáπ ·ä†·àõ·à≠·äõ","am"), ("üá´üáÆ Suomi","fi"),
("üáßüá© ‡¶¨‡¶æ‡¶Ç‡¶≤‡¶æ","bn"), ("üá∞üá™ Kiswahili","sw"), ("üá™üáπ Oromo","om"), ("üá≥üáµ ‡§®‡•á‡§™‡§æ‡§≤‡•Ä","ne"),
("üáµüá± Polski","pl"), ("üá¨üá∑ ŒïŒªŒªŒ∑ŒΩŒπŒ∫Œ¨","el"), ("üá®üáø ƒåe≈°tina","cs"), ("üáÆüá∏ √çslenska","is"),
("üá±üáπ Lietuvi≈≥","lt"), ("üá±üáª Latvie≈°u","lv"), ("üá≠üá∑ Hrvatski","hr"), ("üá∑üá∏ Bosanski","bs"),
("üá≠üá∫ Magyar","hu"), ("üá∑üá¥ Rom√¢nƒÉ","ro"), ("üá∏üá¥ Somali","so"), ("üá≤üáæ Melayu","ms"),
("üá∫üáø O'zbekcha","uz"), ("üáµüá≠ Tagalog","tl"), ("üáµüáπ Portugu√™s","pt")
]

user_mode = {}
user_transcriptions = {}
action_usage = {}
user_selected_lang = {}
pending_files = {}

bot = telebot.TeleBot(BOT_TOKEN, threaded=True)
flask_app = Flask(__name__)

def get_user_mode(uid):
    return user_mode.get(uid, "üìÑ Text File")

def groq_chat_call(payload):
    headers = {"Authorization": f"Bearer {GROQ_API_KEY}", "Content-Type": "application/json"}
    resp = requests.post(GROQ_CHAT_URL, headers=headers, json=payload, timeout=REQUEST_TIMEOUT)
    resp.raise_for_status()
    try:
        return resp.json()
    except Exception:
        return {"response": resp.text}

def ask_groq(text, instruction):
    messages = []
    if instruction:
        messages.append({"role": "system", "content": instruction})
    messages.append({"role": "user", "content": text})
    payload = {"model": GROQ_MODEL, "messages": messages}
    data = groq_chat_call(payload)
    if isinstance(data, dict):
        if "choices" in data and isinstance(data["choices"], list) and data["choices"]:
            first = data["choices"][0]
            if isinstance(first, dict):
                for k in ("message", "text", "content", "output"):
                    if k in first:
                        val = first.get(k)
                        if isinstance(val, dict) and "content" in val:
                            return val.get("content")
                        if isinstance(val, str):
                            return val
            if isinstance(first, str):
                return first
        if "response" in data:
            return data["response"]
        if "answer" in data:
            return data["answer"]
        if "output" in data:
            return data["output"]
        if "data" in data and isinstance(data["data"], str):
            return data["data"]
    return str(data)

def transcribe_media_groq(file_url, mime_type, language_code):
    r = requests.get(file_url, timeout=REQUEST_TIMEOUT)
    r.raise_for_status()
    file_bytes = r.content
    files = {"file": ("audio", BytesIO(file_bytes), mime_type)}
    data = {"model": GROQ_TRANSCRIBE_MODEL}
    if language_code:
        data["language"] = language_code
    headers = {"Authorization": f"Bearer {GROQ_API_KEY}"}
    resp = requests.post(GROQ_TRANSCRIBE_URL, headers=headers, data=data, files=files, timeout=REQUEST_TIMEOUT)
    resp.raise_for_status()
    try:
        parsed = resp.json()
    except Exception:
        return resp.text
    if isinstance(parsed, dict):
        for k in ("text", "transcription", "response", "data", "output"):
            if k in parsed and isinstance(parsed[k], str):
                return parsed[k]
        if "results" in parsed and isinstance(parsed["results"], list) and parsed["results"]:
            first = parsed["results"][0]
            if isinstance(first, dict):
                for k in ("text", "transcription"):
                    if k in first:
                        return first[k]
    return str(parsed)

def build_action_keyboard(text_len):
    btns = []
    if text_len > 1000:
        btns.append([InlineKeyboardButton("Get Summarize", callback_data="summarize_menu|")])
    return InlineKeyboardMarkup(btns)

def build_lang_keyboard(origin):
    btns, row = [], []
    for i, (lbl, code) in enumerate(LANGS, 1):
        row.append(InlineKeyboardButton(lbl, callback_data=f"lang|{code}|{lbl}|{origin}"))
        if i % 3 == 0:
            btns.append(row)
            row = []
    if row:
        btns.append(row)
    return InlineKeyboardMarkup(btns)

def build_summarize_keyboard(origin):
    btns = [
        [InlineKeyboardButton("Short", callback_data=f"summopt|Short|{origin}")],
        [InlineKeyboardButton("Detailed", callback_data=f"summopt|Detailed|{origin}")],
        [InlineKeyboardButton("Bulleted", callback_data=f"summopt|Bulleted|{origin}")]
    ]
    return InlineKeyboardMarkup(btns)

def ensure_joined(message):
    if not REQUIRED_CHANNEL:
        return True
    try:
        if bot.get_chat_member(REQUIRED_CHANNEL, message.from_user.id).status in ['member', 'administrator', 'creator']:
            return True
    except:
        pass
    clean = REQUIRED_CHANNEL.replace("@", "")
    kb = InlineKeyboardMarkup([[InlineKeyboardButton("üîó Join", url=f"https://t.me/{clean}")]])
    bot.reply_to(message, "First, join my channel and come back üëç", reply_markup=kb)
    return False

@bot.message_handler(commands=['start', 'help'])
def send_welcome(message):
    if ensure_joined(message):
        welcome_text = (
            "üëã Salaam!\n"
            "‚Ä¢ Send me\n"
            "‚Ä¢ voice message\n"
            "‚Ä¢ audio file\n"
            "‚Ä¢ video\n"
            "‚Ä¢ to transcribe using Groq API\n\n"
            "Select the language spoken in your audio or video:"
        )
        kb = build_lang_keyboard("file")
        bot.reply_to(message, welcome_text, reply_markup=kb, parse_mode="Markdown")

@bot.message_handler(commands=['mode'])
def choose_mode(message):
    if ensure_joined(message):
        kb = InlineKeyboardMarkup([
            [InlineKeyboardButton("üí¨ Split messages", callback_data="mode|Split messages")],
            [InlineKeyboardButton("üìÑ Text File", callback_data="mode|Text File")]
        ])
        bot.reply_to(message, "How do I send you long transcripts?:", reply_markup=kb)

@bot.callback_query_handler(func=lambda c: c.data.startswith('mode|'))
def mode_cb(call):
    if not ensure_joined(call.message):
        return
    mode = call.data.split("|")[1]
    user_mode[call.from_user.id] = mode
    try:
        bot.edit_message_text(f"you choosed: {mode}", call.message.chat.id, call.message.message_id, reply_markup=None)
    except:
        pass
    bot.answer_callback_query(call.id, f"Mode set to: {mode} ‚òëÔ∏è")

@bot.message_handler(commands=['lang'])
def lang_command(message):
    if ensure_joined(message):
        kb = build_lang_keyboard("file")
        bot.reply_to(message, "Select the language spoken in your audio or video:", reply_markup=kb)

@bot.callback_query_handler(func=lambda c: c.data.startswith('lang|'))
def lang_cb(call):
    _, code, lbl, origin = call.data.split("|")
    if origin != "file":
        try:
            bot.edit_message_reply_markup(call.message.chat.id, call.message.message_id, reply_markup=None)
        except:
            pass
        process_text_action(call, origin, f"Translate to {lbl}", f"Translate this text in to language {lbl}. No extra text ONLY return the translated text.")
        return
    try:
        bot.delete_message(call.message.chat.id, call.message.message_id)
    except:
        try:
            bot.edit_message_reply_markup(call.message.chat.id, call.message.message_id, reply_markup=None)
        except:
            pass
    chat_id = call.message.chat.id
    user_selected_lang[chat_id] = code
    bot.answer_callback_query(call.id, f"Language set: {lbl} ‚òëÔ∏è")
    pending = pending_files.pop(chat_id, None)
    if not pending:
        return
    file_url = pending.get("url")
    mime_type = pending.get("mime")
    orig_msg = pending.get("message")
    bot.send_chat_action(chat_id, 'typing')
    try:
        text = transcribe_media_groq(file_url, mime_type, code)
        if not text:
            raise ValueError("Empty transcription")
        sent = send_long_text(chat_id, text, orig_msg.id, orig_msg.from_user.id)
        if sent:
            user_transcriptions.setdefault(chat_id, {})[sent.message_id] = {"text": text, "origin": orig_msg.id}
            if len(text) > 0:
                try:
                    bot.edit_message_reply_markup(chat_id, sent.message_id, reply_markup=build_action_keyboard(len(text)))
                except:
                    pass
    except Exception as e:
        bot.send_message(chat_id, f"‚ùå Error: {e}")

@bot.callback_query_handler(func=lambda c: c.data.startswith('summarize_menu|'))
def action_cb(call):
    try:
        bot.edit_message_reply_markup(call.message.chat.id, call.message.message_id, reply_markup=build_summarize_keyboard(call.message.id))
    except:
        try:
            bot.answer_callback_query(call.id, "Opening summarize options...")
        except:
            pass

@bot.callback_query_handler(func=lambda c: c.data.startswith('summopt|'))
def summopt_cb(call):
    try:
        _, style, origin = call.data.split("|")
    except:
        bot.answer_callback_query(call.id, "Invalid option", show_alert=True)
        return
    try:
        bot.edit_message_reply_markup(call.message.chat.id, call.message.message_id, reply_markup=None)
    except:
        pass
    prompt = ""
    if style == "Short":
        prompt = "Summarize this text in the original language in 1-2 concise sentences. No extra text ‚Äî return only the summary."
    elif style == "Detailed":
        prompt = "Summarize this text in the original language in a detailed paragraph preserving key points. No extra text ‚Äî return only the summary."
    else:
        prompt = "Summarize this text in the original language as a bulleted list of main points. No extra text ‚Äî return only the summary."
    process_text_action(call, origin, f"Summarize ({style})", prompt)

def process_text_action(call, origin_msg_id, log_action, prompt_instr):
    chat_id = call.message.chat.id
    try:
        origin_id = int(origin_msg_id)
    except:
        origin_id = call.message.message_id
    data = user_transcriptions.get(chat_id, {}).get(origin_id)
    if not data:
        if call.message.reply_to_message:
             data = user_transcriptions.get(chat_id, {}).get(call.message.reply_to_message.message_id)
    if not data:
        bot.answer_callback_query(call.id, "Data not found (expired). Resend file.", show_alert=True)
        return
    text = data["text"]
    bot.answer_callback_query(call.id, "Processing...")
    bot.send_chat_action(chat_id, 'typing')
    try:
        res = ask_groq(text, prompt_instr)
        send_long_text(chat_id, res, data["origin"], call.from_user.id, log_action)
    except Exception as e:
        bot.send_message(chat_id, f"Error: {e}")

@bot.message_handler(content_types=['voice', 'audio', 'video', 'document'])
def handle_media(message):
    if not ensure_joined(message):
        return
    media = message.voice or message.audio or message.video or message.document
    if not media:
        return
    if getattr(media, 'file_size', 0) > MAX_UPLOAD_SIZE:
        bot.reply_to(message, f"File too large. Gemini inline limit is {MAX_UPLOAD_MB}MB.")
        return
    mime_type = "audio/mp3"
    if message.voice: mime_type = "audio/ogg"
    elif message.audio: mime_type = message.audio.mime_type or "audio/mp3"
    elif message.video: mime_type = message.video.mime_type or "video/mp4"
    elif message.document:
        mime_type = message.document.mime_type or mimetypes.guess_type(message.document.file_name)[0] or "audio/mp3"
    bot.send_chat_action(message.chat.id, 'typing')
    try:
        file_info = bot.get_file(media.file_id)
        telegram_file_url = f"https://api.telegram.org/file/bot{BOT_TOKEN}/{file_info.file_path}"
        lang = user_selected_lang.get(message.chat.id)
        if not lang:
            pending_files[message.chat.id] = {"url": telegram_file_url, "mime": mime_type, "message": message}
            kb = build_lang_keyboard("file")
            bot.reply_to(message, "Select the language spoken in your audio or video:", reply_markup=kb)
            return
        text = transcribe_media_groq(telegram_file_url, mime_type, lang)
        if not text:
            raise ValueError("Empty response")
        sent = send_long_text(message.chat.id, text, message.id, message.from_user.id)
        if sent:
            user_transcriptions.setdefault(message.chat.id, {})[sent.message_id] = {"text": text, "origin": message.id}
            if len(text) > 0:
                try:
                    bot.edit_message_reply_markup(message.chat.id, sent.message_id, reply_markup=build_action_keyboard(len(text)))
                except:
                    pass
    except Exception as e:
        bot.reply_to(message, f"‚ùå Error: {e}")

def send_long_text(chat_id, text, reply_id, uid, action="Transcript"):
    mode = get_user_mode(uid)
    if len(text) > MAX_MESSAGE_CHUNK:
        if mode == "Split messages":
            sent = None
            for i in range(0, len(text), MAX_MESSAGE_CHUNK):
                sent = bot.send_message(chat_id, text[i:i+MAX_MESSAGE_CHUNK], reply_to_message_id=reply_id)
            return sent
        else:
            fname = os.path.join(DOWNLOADS_DIR, f"{action}.txt")
            with open(fname, "w", encoding="utf-8") as f:
                f.write(text)
            sent = bot.send_document(chat_id, open(fname, 'rb'), caption="Open this file and copy the text inside üëç", reply_to_message_id=reply_id)
            os.remove(fname)
            return sent
    return bot.send_message(chat_id, text, reply_to_message_id=reply_id)

def _process_webhook_update(raw):
    try:
        upd = Update.de_json(raw.decode('utf-8'))
        bot.process_new_updates([upd])
    except Exception as e:
        logging.exception(f"Error processing update: {e}")

@flask_app.route("/", methods=["GET"])
def index():
    return "Bot Running", 200

@flask_app.route(WEBHOOK_PATH, methods=['POST'])
def webhook():
    if request.headers.get('content-type') == 'application/json':
        data = request.get_data()
        threading.Thread(target=_process_webhook_update, args=(data,), daemon=True).start()
        return '', 200
    abort(403)

if __name__ == "__main__":
    if WEBHOOK_URL:
        bot.remove_webhook()
        time.sleep(0.5)
        bot.set_webhook(url=WEBHOOK_URL)
        flask_app.run(host="0.0.0.0", port=PORT)
    else:
        print("Webhook URL not set, exiting.")
